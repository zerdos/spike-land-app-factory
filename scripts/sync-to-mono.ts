#!/usr/bin/env tsx

/**
 * Sync completed apps to the spike-land-nextjs monorepo
 *
 * Usage: yarn sync [--all | <app-name>]
 *
 * This script:
 * 1. Finds apps in COMPLETE phase
 * 2. Copies them to packages/react-app-examples/ in the monorepo
 * 3. Updates the index file
 */

import * as fs from "fs";
import * as path from "path";

// ============================================================================
// Constants
// ============================================================================

const APPS_DIR = path.join(__dirname, "../apps");
const STATE_FILE = path.join(__dirname, "../.state/apps.json");
const MONOREPO_PATH = path.join(__dirname, "../../spike-land-nextjs");
const TARGET_DIR = path.join(MONOREPO_PATH, "packages/react-app-examples");

// ============================================================================
// Types
// ============================================================================

interface AppState {
  name: string;
  category: string;
  phase: string;
}

interface StateFile {
  apps: Record<string, AppState>;
}

// ============================================================================
// Helpers
// ============================================================================

function loadState(): StateFile {
  if (!fs.existsSync(STATE_FILE)) {
    return { apps: {} };
  }
  return JSON.parse(fs.readFileSync(STATE_FILE, "utf-8"));
}

function getCompletedApps(): AppState[] {
  const state = loadState();
  return Object.values(state.apps).filter((app) => app.phase === "complete");
}

function ensureTargetDir(): void {
  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR, { recursive: true });
    console.log(`üìÅ Created ${TARGET_DIR}`);
  }

  // Create category directories
  const categories = ["utility", "visualization", "productivity", "interactive", "health", "dogs", "lucky"];
  for (const category of categories) {
    const categoryDir = path.join(TARGET_DIR, category);
    if (!fs.existsSync(categoryDir)) {
      fs.mkdirSync(categoryDir, { recursive: true });
    }
  }
}

function syncApp(app: AppState): boolean {
  const sourceFile = path.join(APPS_DIR, app.category, `${app.name}.tsx`);
  const targetFile = path.join(TARGET_DIR, app.category, `${app.name}.tsx`);

  if (!fs.existsSync(sourceFile)) {
    console.error(`   ‚ùå Source file not found: ${sourceFile}`);
    return false;
  }

  // Check if target already exists and compare
  if (fs.existsSync(targetFile)) {
    const sourceContent = fs.readFileSync(sourceFile, "utf-8");
    const targetContent = fs.readFileSync(targetFile, "utf-8");

    if (sourceContent === targetContent) {
      console.log(`   ‚è≠Ô∏è  ${app.name} - Already synced (no changes)`);
      return true;
    }
  }

  // Copy the file
  fs.copyFileSync(sourceFile, targetFile);
  console.log(`   ‚úÖ ${app.name} ‚Üí ${app.category}/${app.name}.tsx`);
  return true;
}

function generateIndex(): void {
  const state = loadState();
  const completedApps = getCompletedApps();

  if (completedApps.length === 0) {
    return;
  }

  // Group by category
  const byCategory: Record<string, AppState[]> = {};
  for (const app of completedApps) {
    if (!byCategory[app.category]) {
      byCategory[app.category] = [];
    }
    byCategory[app.category].push(app);
  }

  // Generate index.ts
  let indexContent = `/**
 * React App Examples Index
 *
 * Auto-generated by sync-to-mono.ts
 * Last updated: ${new Date().toISOString()}
 */

`;

  for (const [category, apps] of Object.entries(byCategory).sort()) {
    indexContent += `// ${category.charAt(0).toUpperCase() + category.slice(1)}\n`;
    for (const app of apps.sort((a, b) => a.name.localeCompare(b.name))) {
      const importName = app.name
        .split("-")
        .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
        .join("");
      indexContent += `export { default as ${importName} } from "./${category}/${app.name}";\n`;
    }
    indexContent += "\n";
  }

  const indexFile = path.join(TARGET_DIR, "index.ts");
  fs.writeFileSync(indexFile, indexContent);
  console.log(`\nüìù Generated index.ts with ${completedApps.length} exports`);
}

function generateReadme(): void {
  const completedApps = getCompletedApps();

  if (completedApps.length === 0) {
    return;
  }

  // Group by category
  const byCategory: Record<string, AppState[]> = {};
  for (const app of completedApps) {
    if (!byCategory[app.category]) {
      byCategory[app.category] = [];
    }
    byCategory[app.category].push(app);
  }

  let readme = `# React App Examples

A collection of single-file React apps built with shadcn/ui and Tailwind CSS.

## Apps (${completedApps.length} total)

`;

  for (const [category, apps] of Object.entries(byCategory).sort()) {
    const categoryTitle = category.charAt(0).toUpperCase() + category.slice(1);
    readme += `### ${categoryTitle} (${apps.length})\n\n`;

    for (const app of apps.sort((a, b) => a.name.localeCompare(b.name))) {
      const displayName = app.name
        .split("-")
        .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" ");
      readme += `- **${displayName}** - \`${category}/${app.name}.tsx\`\n`;
    }
    readme += "\n";
  }

  readme += `## Usage

Each app is a self-contained React component that can be imported directly:

\`\`\`tsx
import { PomodoroTimer } from "@spike-land/react-app-examples";

function MyPage() {
  return <PomodoroTimer />;
}
\`\`\`

Or load dynamically:

\`\`\`tsx
const App = lazy(() => import("@spike-land/react-app-examples/utility/pomodoro-timer"));
\`\`\`

## Requirements

- React 18+
- Tailwind CSS
- shadcn/ui components
- lucide-react (for icons)
- recharts (for data visualization apps)

## License

MIT - See main repository license.
`;

  const readmeFile = path.join(TARGET_DIR, "README.md");
  fs.writeFileSync(readmeFile, readme);
  console.log(`üìñ Generated README.md`);
}

// ============================================================================
// Commands
// ============================================================================

function syncAll(): void {
  const completedApps = getCompletedApps();

  if (completedApps.length === 0) {
    console.log("No completed apps to sync.");
    console.log("\nComplete apps by running through all phases:");
    console.log("  plan ‚Üí develop ‚Üí test ‚Üí debug ‚Üí polish ‚Üí complete");
    return;
  }

  console.log(`\nüîÑ Syncing ${completedApps.length} completed apps to monorepo...\n`);

  ensureTargetDir();

  let synced = 0;
  for (const app of completedApps) {
    if (syncApp(app)) {
      synced++;
    }
  }

  generateIndex();
  generateReadme();

  console.log(`\n‚úÖ Synced ${synced}/${completedApps.length} apps to:`);
  console.log(`   ${TARGET_DIR}`);
}

function syncOne(appName: string): void {
  const state = loadState();
  const app = state.apps[appName];

  if (!app) {
    console.error(`‚ùå App "${appName}" not found in state`);
    process.exit(1);
  }

  if (app.phase !== "complete") {
    console.error(`‚ùå App "${appName}" is not complete (phase: ${app.phase})`);
    console.error(`   Complete the app before syncing.`);
    process.exit(1);
  }

  console.log(`\nüîÑ Syncing ${appName}...\n`);

  ensureTargetDir();

  if (syncApp(app)) {
    generateIndex();
    generateReadme();
    console.log(`\n‚úÖ Synced ${appName} to monorepo`);
  }
}

// ============================================================================
// Main
// ============================================================================

const [, , arg] = process.argv;

if (!arg || arg === "--all") {
  syncAll();
} else if (arg === "--help" || arg === "-h") {
  console.log("Sync completed apps to spike-land-nextjs monorepo");
  console.log("");
  console.log("Usage:");
  console.log("  yarn sync           - Sync all completed apps");
  console.log("  yarn sync --all     - Sync all completed apps");
  console.log("  yarn sync <app>     - Sync a specific app");
} else {
  syncOne(arg);
}
