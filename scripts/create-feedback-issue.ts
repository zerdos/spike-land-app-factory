#!/usr/bin/env tsx

/**
 * Feedback Issue Creator
 *
 * Captures broken code snapshots and creates GitHub issues with before/after diffs
 * when a transpilation fix is applied via orchestrate:advance --success.
 */

import * as fs from "fs";
import * as path from "path";
import * as os from "os";
import { execSync } from "child_process";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SNAPSHOTS_DIR = path.join(__dirname, "../.state/snapshots");
const APPS_DIR = path.join(__dirname, "../apps");

interface SnapshotMeta {
  appName: string;
  category: string;
  phase: string;
  errorMessage: string;
  timestamp: string;
}

// ============================================================================
// Snapshot Management
// ============================================================================

export function snapshotBrokenCode(
  appName: string,
  category: string,
  phase: string,
  errorMessage: string
): void {
  const appFile = findAppFile(appName, category);
  if (!appFile) {
    console.warn(`  [feedback] App file not found for ${appName}, skipping snapshot`);
    return;
  }

  const snapshotDir = path.join(SNAPSHOTS_DIR, appName);
  fs.mkdirSync(snapshotDir, { recursive: true });

  // Copy current broken code
  fs.copyFileSync(appFile, path.join(snapshotDir, "broken.tsx"));

  // Write metadata
  const meta: SnapshotMeta = {
    appName,
    category,
    phase,
    errorMessage,
    timestamp: new Date().toISOString(),
  };
  fs.writeFileSync(path.join(snapshotDir, "error.json"), JSON.stringify(meta, null, 2));

  console.log(`  [feedback] Snapshot saved for ${appName}`);
}

export function hasSnapshot(appName: string): boolean {
  return fs.existsSync(path.join(SNAPSHOTS_DIR, appName, "broken.tsx"));
}

export function createFeedbackIssue(appName: string): void {
  const snapshotDir = path.join(SNAPSHOTS_DIR, appName);
  const brokenFile = path.join(snapshotDir, "broken.tsx");
  const metaFile = path.join(snapshotDir, "error.json");

  if (!fs.existsSync(brokenFile) || !fs.existsSync(metaFile)) {
    console.warn(`  [feedback] No snapshot found for ${appName}`);
    return;
  }

  const meta: SnapshotMeta = JSON.parse(fs.readFileSync(metaFile, "utf-8"));
  const brokenCode = fs.readFileSync(brokenFile, "utf-8");

  // Find the current (fixed) app file
  const fixedFile = findAppFile(appName, meta.category);
  if (!fixedFile) {
    console.warn(`  [feedback] Fixed app file not found for ${appName}`);
    return;
  }
  const fixedCode = fs.readFileSync(fixedFile, "utf-8");

  // Generate diff
  const diff = generateDiff(brokenCode, fixedCode, appName);

  // Calculate time in broken state
  const brokenAt = new Date(meta.timestamp);
  const fixedAt = new Date();
  const durationMs = fixedAt.getTime() - brokenAt.getTime();
  const durationMin = Math.round(durationMs / 60000);

  // Compose issue body
  const body = `## Transpilation Fix: ${appName}

**App:** \`${appName}\`
**Category:** ${meta.category}
**Phase at failure:** ${meta.phase}
**Time in broken state:** ${durationMin} minutes

### Error Message
\`\`\`
${meta.errorMessage}
\`\`\`

### Diff
\`\`\`diff
${diff}
\`\`\`

<details>
<summary>Broken code (click to expand)</summary>

\`\`\`tsx
${brokenCode}
\`\`\`
</details>

<details>
<summary>Fixed code (click to expand)</summary>

\`\`\`tsx
${fixedCode}
\`\`\`
</details>

---
*Auto-generated by app-factory feedback loop*
`;

  // Write body to temp file to avoid shell escaping issues
  const tmpFile = path.join(os.tmpdir(), `feedback-${appName}-${Date.now()}.md`);
  fs.writeFileSync(tmpFile, body);

  try {
    const labels = [
      "transpilation-fix",
      "learning-opportunity",
      "auto-generated",
      `phase:${meta.phase}`,
      `category:${meta.category}`,
    ].join(",");

    const title = `[Fix] ${appName}: ${meta.phase} phase transpilation fix`;

    execSync(
      `gh issue create --repo zerdos/spike-land-app-factory --title "${title}" --label "${labels}" --body-file "${tmpFile}"`,
      { stdio: "inherit" }
    );

    console.log(`  [feedback] GitHub issue created for ${appName}`);
  } finally {
    // Clean up temp file
    if (fs.existsSync(tmpFile)) fs.unlinkSync(tmpFile);
  }

  cleanupSnapshot(appName);
}

export function cleanupSnapshot(appName: string): void {
  const snapshotDir = path.join(SNAPSHOTS_DIR, appName);
  if (fs.existsSync(snapshotDir)) {
    fs.rmSync(snapshotDir, { recursive: true });
    console.log(`  [feedback] Snapshot cleaned up for ${appName}`);
  }
}

// ============================================================================
// Helpers
// ============================================================================

function findAppFile(appName: string, category: string): string | null {
  const primary = path.join(APPS_DIR, category, `${appName}.tsx`);
  if (fs.existsSync(primary)) return primary;

  // Search all categories as fallback
  const categories = fs.readdirSync(APPS_DIR, { withFileTypes: true })
    .filter((d) => d.isDirectory())
    .map((d) => d.name);

  for (const cat of categories) {
    const filePath = path.join(APPS_DIR, cat, `${appName}.tsx`);
    if (fs.existsSync(filePath)) return filePath;
  }

  return null;
}

function generateDiff(broken: string, fixed: string, appName: string): string {
  const tmpBroken = path.join(os.tmpdir(), `broken-${appName}.tsx`);
  const tmpFixed = path.join(os.tmpdir(), `fixed-${appName}.tsx`);

  fs.writeFileSync(tmpBroken, broken);
  fs.writeFileSync(tmpFixed, fixed);

  try {
    // diff returns exit code 1 when files differ, which is expected
    const result = execSync(
      `diff -u "${tmpBroken}" "${tmpFixed}" || true`,
      { encoding: "utf-8" }
    );
    return result || "(no differences)";
  } finally {
    if (fs.existsSync(tmpBroken)) fs.unlinkSync(tmpBroken);
    if (fs.existsSync(tmpFixed)) fs.unlinkSync(tmpFixed);
  }
}

// ============================================================================
// CLI entry point (for manual use via `yarn feedback <app-name>`)
// ============================================================================

const [, , command, appName] = process.argv;

if (command === "snapshot" && appName) {
  // Manual snapshot: yarn feedback snapshot <app-name> <category> <phase> <error>
  const [, , , , category, phase, ...errorParts] = process.argv;
  snapshotBrokenCode(appName, category || "unknown", phase || "unknown", errorParts.join(" ") || "Manual snapshot");
} else if (command === "create" && appName) {
  // Manual issue creation: yarn feedback create <app-name>
  createFeedbackIssue(appName);
} else if (command === "check" && appName) {
  console.log(hasSnapshot(appName) ? "Snapshot exists" : "No snapshot");
} else if (command) {
  console.log("Usage:");
  console.log("  yarn feedback snapshot <app-name> <category> <phase> <error>");
  console.log("  yarn feedback create <app-name>");
  console.log("  yarn feedback check <app-name>");
}
